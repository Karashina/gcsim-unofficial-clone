// Code generated by "pipeline"; DO NOT EDIT.
package lauma

import (
	_ "embed"

	"fmt"
	"slices"

	"github.com/genshinsim/gcsim/pkg/core/action"
	"github.com/genshinsim/gcsim/pkg/core/keys"
	"github.com/genshinsim/gcsim/pkg/gcs/validation"
	"github.com/genshinsim/gcsim/pkg/model"
	"google.golang.org/protobuf/encoding/prototext"
)

//go:embed data_gen.textproto
var pbData []byte
var base *model.AvatarData
var paramKeysValidation = map[action.Action][]string{
	1: {"hold"},
}

func init() {
	base = &model.AvatarData{}
	err := prototext.Unmarshal(pbData, base)
	if err != nil {
		panic(err)
	}
	validation.RegisterCharParamValidationFunc(keys.Lauma, ValidateParamKeys)
}

func ValidateParamKeys(a action.Action, keys []string) error {
	valid, ok := paramKeysValidation[a]
	if !ok {
		return nil
	}
	for _, v := range keys {
		if !slices.Contains(valid, v) {
			return fmt.Errorf("key %v is invalid for action %v", v, a.String())
		}
	}
	return nil
}

func (x *char) Data() *model.AvatarData {
	return base
}

var (
	attack = [][]float64{
		attack_1,
		attack_2,
		attack_3,
	}
)

var (
	// attack: attack_1 = [0]
	attack_1 = []float64{}
	// attack: attack_2 = [1]
	attack_2 = []float64{}
	// attack: attack_3 = [2]
	attack_3 = []float64{}
	// skill: skillPress = [0]
	skillPress = []float64{}
	// skill: skillHold1 = [1]
	skillHold1 = []float64{}
	// skill: skillHold2 = [2]
	skillHold2 = []float64{}
	// skill: skillDotATK = [3]
	skillDotATK = []float64{}
	// skill: skillDotEM = [4]
	skillDotEM = []float64{}
	// burst: burstBuffBloom = [0]
	burstBuffBloom = []float64{}
	// burst: burstBuffLBloom = [1]
	burstBuffLBloom = []float64{}
)
