package albedo

import (
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/attacks"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/attributes"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/combat"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/event"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/geometry"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/glog"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/player/character"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/core/player/shield"
	"github.com/Karashina/gcsim-unofficial-clone/pkg/modifier"
)

const (
	// Transient Blossoms generated by Abiogenesis: Solar Isotoma grant Albedo Fatal Reckoning for 30s:
	// • Unleashing Rite of Progeniture: Tectonic Tide consumes all stacks of Fatal Reckoning. Each stack of Fatal Reckoning consumed increases the DMG dealt by Fatal Blossoms and Rite of Progeniture: Tectonic Tide's burst DMG by 30% of Albedo's DEF.
	// • This effect stacks up to 4 times.
	c2key = "albedo-c2"

	// C1 DEF buff key
	c1DEFKey      = "albedo-c1-def"
	c1DEFDuration = 20 * 60 // 20s

	// C6 additional buff key
	c6BlossomBuffKey      = "albedo-c6-blossom"
	c6BlossomBuffDuration = 20 * 60 // 20s
)

// C1 additional buff:
// The use of Albedo's Elemental Skill also increases his DEF by 50% for the next 20s.
func (c *char) c1DEFBuff() {
	if c.Base.Cons < 1 {
		return
	}
	m := make([]float64, attributes.EndStatType)
	m[attributes.DEFP] = 0.50
	c.AddStatMod(character.StatMod{
		Base:         modifier.NewBaseWithHitlag(c1DEFKey, c1DEFDuration),
		AffectedStat: attributes.DEFP,
		Amount: func() ([]float64, bool) {
			return m, true
		},
	})
	c.Core.Log.NewEvent("Albedo C1: DEF +50% applied", glog.LogCharacterEvent, c.Index)
}

// C2 additional buff:
// When Albedo is not on the field and when the stack count of Fatal Reckoning reaches 4,
// all stacks of Fatal Reckoning are consumed. This generates 3 Fatal Blossoms near your character,
// which will violently bloom to deal AoE Geo DMG equal to 300% of Albedo's DEF, DMG that will also
// be considered Elemental Burst DMG. Where the Passive Talent Homuncular Nature has also been unlocked,
// the Elemental Mastery of nearby party members will also increase by 125 for 10s.
func (c *char) c2AutoBlossom() {
	if c.Base.Cons < 2 {
		return
	}

	c.Core.Events.Subscribe(event.OnEnemyDamage, func(args ...interface{}) bool {
		// Check if Albedo is off-field
		if c.Core.Player.Active() == c.Index {
			return false
		}
		// Check if we have 4 stacks
		if !c.StatusIsActive(c2key) || c.c2stacks < 4 {
			return false
		}

		// Consume all stacks
		stacks := c.c2stacks
		c.c2stacks = 0
		c.DeleteStatus(c2key)

		// Generate 3 Fatal Blossoms
		ai := combat.AttackInfo{
			ActorIndex: c.Index,
			Abil:       "C2 Fatal Blossom",
			AttackTag:  attacks.AttackTagElementalBurst,
			ICDTag:     attacks.ICDTagElementalBurst,
			ICDGroup:   attacks.ICDGroupDefault,
			StrikeType: attacks.StrikeTypeBlunt,
			PoiseDMG:   30,
			Element:    attributes.Geo,
			Durability: 25,
			FlatDmg:    c.TotalDef(false) * 3.0, // 300% DEF
		}

		activePos := c.Core.Combat.Player().Pos()
		for i := 0; i < 3; i++ {
			center := geometry.CalcRandomPointFromCenter(activePos, 0.5, 3.0, c.Core.Rand)
			c.Core.QueueAttack(
				ai,
				combat.NewCircleHitOnTarget(center, nil, 3),
				30+i*10, // delay
				30+i*10,
			)
		}

		// If Homuncular Nature (A4) is unlocked, apply EM buff
		if c.Base.Ascension >= 4 {
			m := make([]float64, attributes.EndStatType)
			m[attributes.EM] = 125
			for _, char := range c.Core.Player.Chars() {
				char.AddStatMod(character.StatMod{
					Base:         modifier.NewBaseWithHitlag("albedo-c2-em", 600), // 10s
					AffectedStat: attributes.EM,
					Amount: func() ([]float64, bool) {
						return m, true
					},
				})
			}
		}

		c.Core.Log.NewEvent("Albedo C2: Auto Fatal Blossom triggered", glog.LogCharacterEvent, c.Index).
			Write("stacks_consumed", stacks)

		return false
	}, "albedo-c2-auto-blossom")
}

// C4:
// Active party members within the Solar Isotoma field have their Plunging Attack DMG increased by 30%.
// Additional (Hexerei): When a nearby active character jumps near a Silver Isotoma, the Silver Isotoma
// will be destroyed while greatly increasing the height of that jump, and for the next 3s, said character
// will deal 30% more Plunging Attack ground impact DMG.
func (c *char) c4(lastConstruct int) func() {
	return func() {
		// don't apply / check again if skill was recast
		if c.lastConstruct != lastConstruct {
			return
		}
		// don't apply / check again if skill isn't active anymore
		if !c.skillActive {
			return
		}

		// apply C4 buff to active char for 1s if within skill area
		inSkillArea := c.Core.Combat.Player().IsWithinArea(c.skillArea)
		if inSkillArea {
			active := c.Core.Player.ActiveChar()
			m := make([]float64, attributes.EndStatType)
			m[attributes.DmgP] = 0.3
			active.AddAttackMod(character.AttackMod{
				Base: modifier.NewBaseWithHitlag("albedo-c4", 60), // 1s
				Amount: func(atk *combat.AttackEvent, _ combat.Target) ([]float64, bool) {
					if atk.Info.AttackTag != attacks.AttackTagPlunge {
						return nil, false
					}
					return m, true
				},
			})
		}

		// check again in 0.3s
		c.Core.Tasks.Add(c.c4(lastConstruct), 18)
	}
}

// c4HexereiJumpBuff: Hexerei C4 additional effect
// When jumping near Silver Isotoma, destroy it and grant +30% Plunging Attack DMG for 3s
func (c *char) c4HexereiJumpBuff() {
	if c.Base.Cons < 4 {
		return
	}
	if !c.isHexerei {
		return
	}

	c.Core.Events.Subscribe(event.OnActionExec, func(args ...interface{}) bool {
		// Check if it's a jump action
		// Note: This is a simplified implementation as gcsim doesn't fully simulate jumps
		// The effect is applied when plunge attack starts
		return false
	}, "albedo-c4-hexerei-jump")

	// Alternative: Apply on plunge attack
	c.Core.Events.Subscribe(event.OnEnemyHit, func(args ...interface{}) bool {
		atk := args[1].(*combat.AttackEvent)
		// Check if it's a plunge attack and within skill area
		if atk.Info.AttackTag != attacks.AttackTagPlunge {
			return false
		}
		if !c.skillActive {
			return false
		}
		if !c.Core.Combat.Player().IsWithinArea(c.skillArea) {
			return false
		}

		// Destroy the construct
		c.Core.Constructs.Destroy(c.lastConstruct)
		c.skillActive = false

		// Apply +30% plunge DMG for 3s to attacker
		attacker := c.Core.Player.Chars()[atk.Info.ActorIndex]
		m := make([]float64, attributes.EndStatType)
		m[attributes.DmgP] = 0.3
		attacker.AddAttackMod(character.AttackMod{
			Base: modifier.NewBaseWithHitlag("albedo-c4-hexerei", 180), // 3s
			Amount: func(atk *combat.AttackEvent, _ combat.Target) ([]float64, bool) {
				if atk.Info.AttackTag != attacks.AttackTagPlunge {
					return nil, false
				}
				return m, true
			},
		})

		c.Core.Log.NewEvent("Albedo C4 Hexerei: Silver Isotoma destroyed, Plunge DMG buff applied", glog.LogCharacterEvent, c.Index)

		return false
	}, "albedo-c4-hexerei-plunge")
}

// C6:
// Active party members within the Solar Isotoma field who are protected by a shield created by Crystallize have their DMG increased by 17%.
func (c *char) c6(lastConstruct int) func() {
	return func() {
		// don't apply / check again if skill was recast
		if c.lastConstruct != lastConstruct {
			return
		}
		// don't apply / check again if skill isn't active anymore
		if !c.skillActive {
			return
		}

		// apply C6 buff to active char for 1s if they are protected by crystallize and within the skill area
		crystallizeShield := c.Core.Player.Shields.Get(shield.Crystallize) != nil
		inSkillArea := c.Core.Combat.Player().IsWithinArea(c.skillArea)
		if crystallizeShield && inSkillArea {
			active := c.Core.Player.ActiveChar()
			m := make([]float64, attributes.EndStatType)
			m[attributes.DmgP] = 0.17
			active.AddStatMod(character.StatMod{
				Base:         modifier.NewBase("albedo-c6", 60), // 1s
				AffectedStat: attributes.DmgP,
				Amount: func() ([]float64, bool) {
					return m, true
				},
			})
		}

		// check again in 0.3s
		c.Core.Tasks.Add(c.c6(lastConstruct), 18)
	}
}

// c6BlossomBuffOnBurst: C6 additional effect (Hexerei)
// Use of Burst destroys all Silver Isotomas, and whenever destroyed this way,
// it removes 4 stacks of Fatal Reckoning and increases Fatal Blossom DMG by 250% DEF for 20s.
func (c *char) c6BlossomBuffOnBurst() {
	if c.Base.Cons < 6 {
		return
	}
	if !c.isHexerei {
		return
	}

	// Track number of Silver Isotomas destroyed
	if c.skillActive {
		// Destroy the Silver Isotoma
		c.Core.Constructs.Destroy(c.lastConstruct)
		c.skillActive = false

		// Remove 4 stacks of Fatal Reckoning per destroyed Isotoma
		if c.c2stacks >= 4 {
			c.c2stacks -= 4
		} else {
			c.c2stacks = 0
		}
		if c.c2stacks == 0 {
			c.DeleteStatus(c2key)
		}

		// Grant Fatal Blossom DMG +250% DEF for 20s
		c.AddStatus(c6BlossomBuffKey, c6BlossomBuffDuration, true)

		c.Core.Log.NewEvent("Albedo C6 Hexerei: Silver Isotoma destroyed on Burst", glog.LogCharacterEvent, c.Index).
			Write("remaining_c2_stacks", c.c2stacks)
	}
}
